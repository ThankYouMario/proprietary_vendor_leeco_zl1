#!/bin/bash
set -e

# Device
VENDOR=leeco
DEVICE=zl1

# Variables
MAKEFILE=${DEVICE}-vendor.mk
AMAKEFILE=Android.mk
PROPRIETARY_FOLDER=proprietary
PROPRIETARY_INDEX=proprietary-index.txt

# Header
HEADER="# Copyright $(date +"%Y") Paranoid Android
#
# Licensed under the Apache License, Version 2.0 (the \"License\");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an \"AS IS\" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# This file was automatically generated by vendor/$VENDOR/$DEVICE/typewriter.sh."

# Write the header to the makefile.
(cat << EOF) > $MAKEFILE
$HEADER
EOF

# Typewriter essential function for querying the proprietary files
# based on the file extension/name argument.
function typwrt {
    echo "Looking for [${2}] files under proprietary folder..."
    echo "" >> $MAKEFILE
    echo "# ${2}" >> $MAKEFILE
    echo -n "PRODUCT_COPY_FILES +=" >> $MAKEFILE
    echo "Index:"
    FILES=$(git ls-files $PROPRIETARY_FOLDER --exclude="*${1}" --ignored)
    for FILE in $FILES; do
        TFILE=$(echo $FILE | sed 's/proprietary/system/')
        echo "/${TFILE}" >> $PROPRIETARY_INDEX
        echo "   vendor/$VENDOR/$DEVICE/$FILE -> $TFILE"
        echo -n " \\
    vendor/$VENDOR/$DEVICE/$FILE:$TFILE" >> $MAKEFILE
    done
    echo "Wrote [${1}] output to $MAKEFILE..."
    echo "" >> $MAKEFILE
}

# If a given blob is handled from Android.mk, we should remove it from
# the copy conditions to avoid trouble.
# Then we write the Android.mk source depending on the nature of that blob.
function andhdl {
    NAME=$1
    EXTENSION=$2
    TARGET=$(grep -E "$NAME.$EXTENSION" $PROPRIETARY_INDEX | sed 's/^[-\/]*//' | sed 's/system/proprietary/')
    echo "Removing $NAME.$EXTENSION from copy conditions..."
    NUM=$(grep -n "$TARGET" $MAKEFILE | sed 's/^\([0-9]\+\):.*$/\1/')
    PREV=$(expr $NUM - 1)
    NEXT=$(expr $NUM + 1)
    PLINE=$(head -n $PREV $MAKEFILE | tail -n 1)
    NLINE=$(head -n $NEXT $MAKEFILE | tail -n 1)
    # If the next line is blank, it's because the target is the last line and won't
    # have "\" at the end of the rule, we'd then remove the "\" from previous line
    # to avoid syntax issues before removing the target line itself.
    if [ $(echo $NLINE | grep -cvP '\S') == 1 ]; then
        echo "Warning: Adjusting backslashes before removing $NAME.$EXTENSION..."
        REPLACE=$(echo $PLINE | sed 's/\\//g' | sed 's/ //g')
        sed -i "${PREV}s|.*|    ${REPLACE}|" $MAKEFILE
    fi
    # After we've checked the previous/next lines, we can safely remove
    # the target line itself.
    sed -i "${NUM}d" $MAKEFILE
    echo "Adding $NAME.$EXTENSION to $AMAKEFILE..."
    echo "
include \$(CLEAR_VARS)
LOCAL_MODULE := $NAME
LOCAL_MODULE_OWNER := $VENDOR" >> $AMAKEFILE
    if [ "$EXTENSION" = "jar" ]; then
        echo "LOCAL_MODULE_CLASS := JAVA_LIBRARIES" >> $AMAKEFILE
        echo -n "LOCAL_MODULE_SUFFIX := \$(COMMON_JAVA_PACKAGE_SUFFIX)" >> $AMAKEFILE
    elif [ "$EXTENSION" = "xml" ]; then
        echo "LOCAL_MODULE_CLASS := ETC" >> $AMAKEFILE
        echo -n "LOCAL_MODULE_SUFFIX := .xml" >> $AMAKEFILE
    fi
    echo "
LOCAL_MODULE_TAGS := optional
LOCAL_CERTIFICATE := platform
LOCAL_SRC_FILES := $TARGET
include \$(BUILD_PREBUILT)" >> $AMAKEFILE
    echo -n " \\
    $NAME" >> $MAKEFILE
}

# Executables
# Because "git ls-files" doesn't handle files without
# extensions properly we ought to use "find" instead.
# Note that for "find" command not to use absolute paths
# we'll hardcode the proprietary path.
echo "Looking for executable files under proprietary folder..."
echo "" >> $MAKEFILE
echo "# Executable Files" >> $MAKEFILE
echo -n "PRODUCT_COPY_FILES +=" >> $MAKEFILE
echo "Index:"
EXECUTABLES=$(find proprietary -executable -type f | sort -u)
for EXECUTABLE in $EXECUTABLES; do
    TEXECUTABLE=$(echo $EXECUTABLE | sed 's/proprietary/system/')
    echo "/${TEXECUTABLE}" > $PROPRIETARY_INDEX
    echo "   vendor/$VENDOR/$DEVICE/$EXECUTABLE -> $TEXECUTABLE"
    echo -n " \\
    vendor/$VENDOR/$DEVICE/$EXECUTABLE:$TEXECUTABLE" >> $MAKEFILE
done
echo "Wrote executables output to $MAKEFILE..."
echo "" >> $MAKEFILE

# Pass the different file types to the common function
# to be parsed and wrote.
# Please, use alphabetical order to make the output file
# easier to understand and navigate.
typwrt ".acdb"  "ACDB"
typwrt ".conf"  "Configuration (A)"
typwrt ".cfg"   "Configuration (B)"
typwrt ".db"    "Database"
typwrt ".jar"   "Java Files"
typwrt ".xml"   "Parsable Files"
typwrt ".so"    "Libraries"
typwrt ".qcom"  "QCOM Files"
typwrt "b0*"    "Firmware Files (A)" # b00, b01, b02, b03...
typwrt ".mbn"   "Firmware Files (B)"
typwrt ".mdt"   "Firmware Files (C)"
typwrt ".elf"   "Firmware Files (D)"
typwrt ".img"   "Firmware Files (E)"
typwrt ".tlv"   "Firmware Files (F)"
typwrt ".bin"   "Firmware Files (G)"
typwrt ".fw"    "Firmware Files (H)"
typwrt ".fw2"   "Firmware Files (I)"
typwrt ".cybin" "Type-C Firmware"
typwrt ".gmm"   "QVOP Firmware"

# Exception cases for files that don't have an extension,
# use the complete name of the file in this case.
typwrt "mbn_upgrade_info"  "Modem Upgrade Info"

# Applications
# This will write the apps to the proprietary index.
echo "Looking for apps under proprietary folder..."
echo "Index:"
APPS=$(git ls-files $PROPRIETARY_FOLDER --exclude="*.apk" --ignored)
for APP in $APPS; do
    TAPP=$(echo $APP | sed 's/proprietary/system/')
    echo "/${TAPP}" >> $PROPRIETARY_INDEX
    echo "   vendor/$VENDOR/$DEVICE/$APP -> $TAPP"
done

# Write out the Android.mk using the proprietary apps
# found on the index.
HAS_APK=false
for APP in $(cat $PROPRIETARY_INDEX | grep -v -E '^ *(#|$)' | grep -E '\.apk *$' | sed 's/^[-\/]*//' | sed 's/system/proprietary/' | sort -s); do
    APK_NAME=$(basename -s .apk $APP)
    if [ "$HAS_APK" != "true" ]; then
        echo -n "
# Applications
PRODUCT_PACKAGES +=" >> $MAKEFILE
        (cat << EOF) > $AMAKEFILE
$HEADER

LOCAL_PATH := \$(call my-dir)

ifeq (\$(TARGET_DEVICE),$DEVICE)

-include vendor/head/zl1/head.mk
EOF
        HAS_APK=true
    fi
    echo -n " \\
    $APK_NAME" >> $MAKEFILE
    echo "
include \$(CLEAR_VARS)
LOCAL_MODULE := $APK_NAME
LOCAL_MODULE_OWNER := $VENDOR
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := \$(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_MODULE_TAGS := optional
LOCAL_DEX_PREOPT := false
LOCAL_CERTIFICATE := platform" >> $AMAKEFILE
    if [[ "$APP" =~ "system/priv-app/".* ]]; then
        echo "LOCAL_PRIVILEGED_MODULE := true" >> $AMAKEFILE
    fi
    echo "LOCAL_SRC_FILES := $APP
include \$(BUILD_PREBUILT)" >> $AMAKEFILE
done
echo "" >> $MAKEFILE

# Android.mk handled blobs need to use packages as well.
# This is fairly common on QCOM devices.
echo -n "
# QCOM Packages
ifeq (\$(QCPATH),)
PRODUCT_PACKAGES +=" >> $MAKEFILE
echo "" >> $AMAKEFILE
echo -n "ifeq (\$(QCPATH),)" >> $AMAKEFILE
andhdl "com.qti.dpmframework" "jar"
andhdl "com.qti.location.sdk" "jar"
andhdl "dpmapi"               "jar"
andhdl "qcnvitems"            "jar"
andhdl "qcrilhook"            "jar"
andhdl "tcmclient"            "jar"
andhdl "qdcm_calib_data_mdss_dsi_ft8716_1080p_video"  "xml"
andhdl "qdcm_calib_data_mdss_dsi_s6d6fa1_1080p_video" "xml"
echo "endif" >> $AMAKEFILE

# Finish the Android.mk file by adjusting the last lines
# and adding the needed shell commands for EGL blobs.
echo "" >> $AMAKEFILE
echo '$(shell mkdir -p $(PRODUCT_OUT)/system/vendor/lib/egl && pushd $(PRODUCT_OUT)/system/vendor/lib > /dev/null && ln -s egl/libEGL_adreno.so libEGL_adreno.so && popd > /dev/null)' >> $AMAKEFILE
echo '$(shell mkdir -p $(PRODUCT_OUT)/system/vendor/lib64/egl && pushd $(PRODUCT_OUT)/system/vendor/lib64 > /dev/null && ln -s egl/libEGL_adreno.so libEGL_adreno.so && popd > /dev/null)' >> $AMAKEFILE
echo "endif" >> $AMAKEFILE

# Finish the makefile file by adding the last blank line.
echo "" >> $MAKEFILE
echo "endif" >> $MAKEFILE

# Bye.
echo ""
echo "Done."
