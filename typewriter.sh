#!/bin/bash
#
# Copyright - √çcaro Hoff <icarohoff@gmail.com>
#
#  _                                  _ _
# | |_ _   _ _ __   _____      ___ __(_) |_ ___ _ __
# | __| | | | '_ \ / _ \ \ /\ / / '__| | __/ _ \ '__|
# | |_| |_| | |_) |  __/\ V  V /| |  | | ||  __/ |
#  \__|\__, | .__/ \___| \_/\_/ |_|  |_|\__\___|_|
#      |___/|_|
#
#

# "Sejhte"
set -e
clear

# Colors
blink=$(tput blink)
red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
white=$(tput setaf 15)
rose=$(tput setaf 5)
cyan=$(tput setaf 14)
normal=$(tput sgr0)

# Verbose?
# Just add -v as argument.
VERBOSE=$1

# Device
# Do I need to say --edit--?
VENDOR=leeco
DEVICE=zl1

# Variables
MAKEFILE=${DEVICE}-vendor.mk
AMAKEFILE=Android.mk
BMAKEFILE=BoardConfigVendor.mk
PROPRIETARY_FOLDER=proprietary
PROPRIETARY_INDEX=proprietary-index.txt

# Awesomeness
SCRIPT_VERSION="Alpha 1.1.7"
SCRIPT_DESCRIPTION="
A colorful neat useless simple-complex script
that generates QCOM vendor makefiles."
EIY_DESCRIPTION="        _ _ _     _ _
 ___ __| (_) |_  (_) |_
/ -_) _  | |  _| | |  _|
\___\__,_|_|\__| |_|\__|   _  __
 _  _ ___ _  _ _ _ ___ ___| |/ _|
| || / _ \ || | '_(_-</ -_) |  _|
 \_, \___/\_,_|_| /__/\___|_|_|
 |__/"
WARNING_DESCRIPTION="
Look for the --EDIT-- badges within the script
to modify it to your needs."
echo -e "${rose}   _                                  _ _"
echo "  | |_ _   _ _ __   _____      ___ __(_) |_ ___ _ __"
echo -e "  | __| | | | '_ \ / _ \ \ /\ / / '__| | __/ _ \ '__|${normal}"
echo -e "${white}${blink}  | |_| |_| | |_) |  __/\ V  V /| |  | | ||  __/ |${normal}"
echo -e "${cyan}   \__|\__, | .__/ \___| \_/\_/ |_|  |_|\__\___|_|"
echo -e "       |___/|_|${normal}"
echo ""
echo -e "${rose}Version:${normal} ${cyan}$SCRIPT_VERSION${normal}"
printf "%s\n" "${white}$SCRIPT_DESCRIPTION${normal}"
printf "%s\n" "${blink}${yellow}$EIY_DESCRIPTION${normal}"
printf "%s\n" "${red}$WARNING_DESCRIPTION${normal}"
echo ""
echo -e "${rose}Please,${normal} ${cyan}${blink}WAIT${normal} ${rose}patiently...${normal}"
echo ""

# Header
HEADER="# Copyright $(date +"%Y") Paranoid Android
#
# Licensed under the Apache License, Version 2.0 (the \"License\");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an \"AS IS\" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# This file was automatically generated by vendor/$VENDOR/$DEVICE/typewriter.sh."

# Write the header to the device's makefile.
(cat << EOF) > $MAKEFILE
$HEADER
EOF

# Write the header to the device's board configuration makefile.
(cat << EOF) > $BMAKEFILE
$HEADER
EOF

# Typewriter's essential function for querying the proprietary files
# based on the file extension/name argument passed to it.
# This uses inverted 'git ls-files' logic to avoid missing anything.
function typwrt {
    if [ "$VERBOSE" = "-v" ]; then
        echo "Looking for [${2}] files under proprietary folder..."
    fi
    echo "" >> $MAKEFILE
    echo "# ${2}" >> $MAKEFILE
    echo -n "PRODUCT_COPY_FILES +=" >> $MAKEFILE
    if [ "$VERBOSE" = "-v" ]; then
        echo "Index:"
    fi
    FILES=$(git ls-files $PROPRIETARY_FOLDER --exclude="*${1}" --ignored)
    for FILE in $FILES; do
        TFILE=$(echo $FILE | sed 's/proprietary/system/')
        echo "/${TFILE}" >> $PROPRIETARY_INDEX
        if [ "$VERBOSE" = "-v" ]; then
            echo "   vendor/$VENDOR/$DEVICE/$FILE -> $TFILE"
        fi
        echo -n " \\
    vendor/$VENDOR/$DEVICE/$FILE:$TFILE" >> $MAKEFILE
    done
    if [ "$VERBOSE" = "-v" ]; then
        echo "Wrote [${1}] output to $MAKEFILE..."
    fi
    echo "" >> $MAKEFILE
}

# Move a certain type of blob to Android.mk taking
# its extension on account:
# XML and JAR are usually the types that we can handle
# from Android.mk as per AOSP rules.
function andhdl {
    NAME=$1
    EXTENSION=$2
    TARGET=$(grep -E "$NAME.$EXTENSION" $PROPRIETARY_INDEX | sed 's/^[-\/]*//' | sed 's/system/proprietary/')
    if [ "$VERBOSE" = "-v" ]; then
        echo "Moving $NAME.$EXTENSION from $MAKEFILE to $AMAKEFILE..."
    fi
    NUM=$(grep -n "$TARGET" $MAKEFILE | sed 's/^\([0-9]\+\):.*$/\1/')
    PREV=$(expr $NUM - 1)
    NEXT=$(expr $NUM + 1)
    PLINE=$(head -n $PREV $MAKEFILE | tail -n 1)
    NLINE=$(head -n $NEXT $MAKEFILE | tail -n 1)
    # If the next line is blank, it's because the target is the last line and won't
    # have "\" at the end of the rule, we'd then remove the "\" from previous line
    # to avoid syntax issues before removing the target line itself.
    if [ $(echo $NLINE | grep -cvP '\S') == 1 ]; then
        echo -e "${yellow}Warning: Adjusting backslashes before removing $NAME.$EXTENSION...${normal}"
        REPLACE=$(echo $PLINE | sed 's/\\//g' | sed 's/ //g')
        sed -i "${PREV}s|.*|    ${REPLACE}|" $MAKEFILE
    fi
    # After we've checked the previous/next lines, we can safely remove
    # the target line itself.
    sed -i "${NUM}d" $MAKEFILE
    echo "
include \$(CLEAR_VARS)
LOCAL_MODULE := $NAME
LOCAL_MODULE_OWNER := $VENDOR" >> $AMAKEFILE
    if [ "$EXTENSION" = "jar" ]; then
        echo "LOCAL_MODULE_CLASS := JAVA_LIBRARIES" >> $AMAKEFILE
        echo -n "LOCAL_MODULE_SUFFIX := \$(COMMON_JAVA_PACKAGE_SUFFIX)" >> $AMAKEFILE
    elif [ "$EXTENSION" = "xml" ]; then
        echo "LOCAL_MODULE_CLASS := ETC" >> $AMAKEFILE
        echo -n "LOCAL_MODULE_SUFFIX := .xml" >> $AMAKEFILE
    fi
    echo "
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $TARGET
include \$(BUILD_PREBUILT)" >> $AMAKEFILE
    echo -n " \\
    $NAME" >> $MAKEFILE
}

# Move a certain library blob to Android.mk taking
# the architecture on account for all cases:
# 32-bit only, 64-bit only and both (multilib).
function andhdlib {
    NAME=$1
    if [ "$VERBOSE" = "-v" ]; then
        echo "Moving $NAME.so from $MAKEFILE to $AMAKEFILE..."
    fi
    TARGET64=$(grep -E "$NAME.so" $PROPRIETARY_INDEX | sed 's/^[-\/]*//' | sed 's/system/proprietary/' | if ! grep 'lib64/'; then echo "null"; fi)
    TARGET32=$(grep -E "$NAME.so" $PROPRIETARY_INDEX | sed 's/^[-\/]*//' | sed 's/system/proprietary/' | if ! grep 'lib/'; then echo "null"; fi)
    if [ "$TARGET32" = "null" ]; then
        if [ "$VERBOSE" = "-v" ]; then
            echo "Library only available for 64-bit."
        fi
        ARCH=64
    elif [ "$TARGET64" = "null" ]; then
        if [ "$VERBOSE" = "-v" ]; then
            echo "Library only available for 32-bit."
        fi
        ARCH=32
    else if [[ ! "$TARGET32" = "null" || "$TARGET64" = "null" ]]; then
        if [ "$VERBOSE" = "-v" ]; then
            echo "Library available for both (64-bit/32-bit)."
        fi
        ARCH=both
    fi
    fi
    if [ "$ARCH" = "32" ]; then
        NUM=$(grep -n "$TARGET32" $MAKEFILE | sed 's/^\([0-9]\+\):.*$/\1/')
        PREV=$(expr $NUM - 1)
        NEXT=$(expr $NUM + 1)
    elif [ "$ARCH" = "64" ]; then
        NUM=$(grep -n "$TARGET64" $MAKEFILE | sed 's/^\([0-9]\+\):.*$/\1/')
        PREV=$(expr $NUM - 1)
        NEXT=$(expr $NUM + 1)
    else if [ "$ARCH" = "both" ]; then
        NUM32=$(grep -n "$TARGET32" $MAKEFILE | sed 's/^\([0-9]\+\):.*$/\1/')
        NUM64=$(grep -n "$TARGET64" $MAKEFILE | sed 's/^\([0-9]\+\):.*$/\1/')
        PREV32=$(expr $NUM32 - 1)
        PREV64=$(expr $NUM64 - 1)
        NEXT32=$(expr $NUM32 + 1)
        NEXT64=$(expr $NUM64 + 1)
    fi
    fi
    if [ "$ARCH" = "both" ]; then
        PLINE32=$(head -n $PREV32 $MAKEFILE | tail -n 1)
        PLINE64=$(head -n $PREV64 $MAKEFILE | tail -n 1)
        NLINE32=$(head -n $NEXT32 $MAKEFILE | tail -n 1)
        NLINE64=$(head -n $NEXT64 $MAKEFILE | tail -n 1)
    else
        PLINE=$(head -n $PREV $MAKEFILE | tail -n 1)
        NLINE=$(head -n $NEXT $MAKEFILE | tail -n 1)
    fi
    # If the next line is blank, it's because the target is the last line and won't
    # have "\" at the end of the rule, we'd then remove the "\" from previous line
    # to avoid syntax issues before removing the target line itself.
    if [ "$ARCH" = "both" ]; then
        # 32-bit library in last line position, almost impossible because "git ls-files" knows the alphabet.
        if [ $(echo $NLINE32 | grep -cvP '\S') == 1 ]; then
            echo -e "${yellow}Warning: Adjusting backslashes before removing 32-bit $NAME.so...${normal}"
            REPLACE32=$(echo $PLINE32 | sed 's/\\//g' | sed 's/ //g')
            sed -i "${PREV32}s|.*|    ${REPLACE32}|" $MAKEFILE
        fi
        # 64-bit library in last line position, likely not to happen but good to have it in place.
        if [ $(echo $NLINE64 | grep -cvP '\S') == 1 ]; then
            echo -e "${yellow}Warning: Adjusting backslashes before removing 64-bit $NAME.so...${normal}"
            REPLACE64=$(echo $PLINE64 | sed 's/\\//g' | sed 's/ //g')
            sed -i "${PREV64}s|.*|    ${REPLACE64}|" $MAKEFILE
        fi
    else
        if [ $(echo $NLINE | grep -cvP '\S') == 1 ]; then
            echo -e "${yellow}Warning: Adjusting backslashes before removing $NAME.so...${normal}"
            REPLACE=$(echo $PLINE | sed 's/\\//g' | sed 's/ //g')
            sed -i "${PREV}s|.*|    ${REPLACE}|" $MAKEFILE
        fi
    fi
    # After we've checked the previous/next lines, we can safely remove
    # the target line itself.
    if [ "$ARCH" = "both" ]; then
        # As we're removing this in a row, we need to step back
        # one line after the 32-bit removal to "fix" the 64-bit one.
        sed -i "${NUM32}d" $MAKEFILE
        sed -i "${PREV64}d" $MAKEFILE
    else
        sed -i "${NUM}d" $MAKEFILE
    fi
    echo "
include \$(CLEAR_VARS)
LOCAL_MODULE := $NAME
LOCAL_MODULE_OWNER := $VENDOR" >> $AMAKEFILE
    if [ "$ARCH" = "32" ]; then
        echo -n "LOCAL_MULTILIB := 32" >> $AMAKEFILE
    elif [ "$ARCH" = "64" ]; then
        echo -n "LOCAL_MULTILIB := 64" >> $AMAKEFILE
    else if [ "$ARCH" = "both" ]; then
        echo -n "LOCAL_MULTILIB := both" >> $AMAKEFILE
    fi
    fi
    echo "
LOCAL_MODULE_CLASS := SHARED_LIBRARIES
LOCAL_MODULE_SUFFIX := .so
LOCAL_MODULE_TAGS := optional" >> $AMAKEFILE
    if [ "$ARCH" = "32" ]; then
        if [[ "$TARGET32" =~ "proprietary/vendor/".* ]]; then
            echo "LOCAL_PROPRIETARY_MODULE := true" >> $AMAKEFILE
        fi
        echo "LOCAL_SRC_FILES := $TARGET32" >> $AMAKEFILE
    elif [ "$ARCH" = "64" ]; then
        if [[ "$TARGET64" =~ "proprietary/vendor/".* ]]; then
            echo "LOCAL_PROPRIETARY_MODULE := true" >> $AMAKEFILE
        fi
        echo "LOCAL_SRC_FILES := $TARGET64" >> $AMAKEFILE
    else if [ "$ARCH" = "both" ]; then
        if [[ "$TARGET64" =~ "proprietary/vendor/".* ]]; then
            echo "LOCAL_PROPRIETARY_MODULE := true" >> $AMAKEFILE
        fi
        echo "LOCAL_SRC_FILES_64 := $TARGET64" >> $AMAKEFILE
        echo "LOCAL_SRC_FILES_32 := $TARGET32" >> $AMAKEFILE
    fi
    fi
echo "include \$(BUILD_PREBUILT)" >> $AMAKEFILE
    echo -n " \\
    $NAME" >> $MAKEFILE
}

# Because "git ls-files" doesn't handle files without
# extensions properly we ought to use "find" instead.
# Note that for "find" command to work we shall not use
# absolute paths, we'll hardcode the "proprietary" path.
# Make sure all executables have at least +x permissions.
if [ "$VERBOSE" = "-v" ]; then
    echo "Looking for executable files under proprietary folder..."
fi
echo "" >> $MAKEFILE
echo "# Executable Files" >> $MAKEFILE
echo -n "PRODUCT_COPY_FILES +=" >> $MAKEFILE
if [ "$VERBOSE" = "-v" ]; then
    echo "Index:"
fi
EXECUTABLES=$(find proprietary -executable -type f | sort -u)
for EXECUTABLE in $EXECUTABLES; do
    TEXECUTABLE=$(echo $EXECUTABLE | sed 's/proprietary/system/')
    echo "/${TEXECUTABLE}" > $PROPRIETARY_INDEX
    if [ "$VERBOSE" = "-v" ]; then
        echo "   vendor/$VENDOR/$DEVICE/$EXECUTABLE -> $TEXECUTABLE"
    fi
    echo -n " \\
    vendor/$VENDOR/$DEVICE/$EXECUTABLE:$TEXECUTABLE" >> $MAKEFILE
done
if [ "$VERBOSE" = "-v" ]; then
    echo "Wrote executables output to $MAKEFILE..."
fi
echo "" >> $MAKEFILE

# Pass the different file types to the common function
# to be parsed and wrote.
# Please, use alphabetical order to make the output file
# easier to understand and navigate.
# Any kind of file extension works, if you have different
#extensions for the same object use some enumerator like A, B, C...
# In case of many splitted files, use a common string with "*" at the end.
# Files without extension can only be parsed individually, e.g.: mbn_upgrade_info.
##########_ _ _ ####
#  ___ __| (_) |_  #
# / -_) _` | |  _| #
# \___\__,_|_|\__| #
####################
typwrt ".acdb"  "ACDB Files"
typwrt ".qwsp"  "ACDB Skeleton"
typwrt ".conf"  "Configuration (A)"
typwrt ".cfg"   "Configuration (B)"
typwrt ".db"    "Database"
typwrt ".jar"   "Java Files"
typwrt ".xml"   "Parsable Files"
typwrt ".so"    "Libraries"
typwrt ".qcom"  "QCOM Files"
typwrt "b0*"    "Firmware Files (A)" # b00, b01, b02, b03...
typwrt ".mbn"   "Firmware Files (B)"
typwrt ".mdt"   "Firmware Files (C)"
typwrt ".elf"   "Firmware Files (D)"
typwrt ".img"   "Firmware Files (E)"
typwrt ".tlv"   "Firmware Files (F)"
typwrt ".bin"   "Firmware Files (G)"
typwrt ".fw"    "Firmware Files (H)"
typwrt ".fw2"   "Firmware Files (I)"
typwrt ".cybin" "Type-C Firmware"
typwrt ".gmm"   "QVOP Firmware"
typwrt ".pem"   "Certificate Files"
typwrt "mbn_upgrade_info"  "Modem Upgrade Info"
####################

# Use 'git ls-files' to get the information of all
# applications under the proprietary folder and
# write them to the index for later usage.
if [ "$VERBOSE" = "-v" ]; then
    echo "Looking for apps under proprietary folder..."
    echo "Index:"
fi
APPS=$(git ls-files $PROPRIETARY_FOLDER --exclude="*.apk" --ignored)
for APP in $APPS; do
    TAPP=$(echo $APP | sed 's/proprietary/system/')
    echo "/${TAPP}" >> $PROPRIETARY_INDEX
    if [ "$VERBOSE" = "-v" ]; then
        echo "   vendor/$VENDOR/$DEVICE/$APP -> $TAPP"
    fi
done

# Write out the Android.mk using the proprietary apps
# found on the index.
# This step is fully automated by the way, yeah.
# Notice that this will force write the Android.mk file.
HAS_APK=false
for APP in $(cat $PROPRIETARY_INDEX | grep -v -E '^ *(#|$)' | grep -E '\.apk *$' | sed 's/^[-\/]*//' | sed 's/system/proprietary/' | sort -s); do
    APK_NAME=$(basename -s .apk $APP)
    if [ "$HAS_APK" != "true" ]; then
        echo -n "
# Applications
PRODUCT_PACKAGES +=" >> $MAKEFILE
        (cat << EOF) > $AMAKEFILE
$HEADER

LOCAL_PATH := \$(call my-dir)

ifeq (\$(TARGET_DEVICE),$DEVICE)

-include vendor/head/$DEVICE/head.mk
EOF
        HAS_APK=true
    fi
    echo -n " \\
    $APK_NAME" >> $MAKEFILE
    echo "
include \$(CLEAR_VARS)
LOCAL_MODULE := $APK_NAME
LOCAL_MODULE_OWNER := $VENDOR
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := \$(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_MODULE_TAGS := optional
LOCAL_DEX_PREOPT := false
LOCAL_CERTIFICATE := platform" >> $AMAKEFILE
    if [[ "$APP" =~ "proprietary/priv-app/".* ]]; then
        echo "LOCAL_PRIVILEGED_MODULE := true" >> $AMAKEFILE
    fi
    if [[ "$APP" =~ "proprietary/vendor/app/".* ]]; then
        echo "LOCAL_PROPRIETARY_MODULE := true" >> $AMAKEFILE
    fi
    echo "LOCAL_SRC_FILES := $APP
include \$(BUILD_PREBUILT)" >> $AMAKEFILE
done
echo "" >> $MAKEFILE

# Android.mk handled blobs need to use package rules
# instead of copy rules.
# This is fairly common on QCOM devices, just add the package
# name for the [.jar, xml or .so] you need as a package rule.
# You can modify the whole structure and even remove the QCPATH
# sanity checks if you don't use them in your AOSP build tree.
# To add create a new package from a .jar/.xml blob, invoke 'andhdl'
# with the name of the package matching the blob and the type.
# e.g.: andhdl tcmclient jar
# This second argument is needed because have this file usually
# exists as an .xml too.
echo -n "
# QCOM Packages
ifeq (\$(QCPATH),)
PRODUCT_PACKAGES +=" >> $MAKEFILE
echo "" >> $AMAKEFILE
echo -n "ifeq (\$(QCPATH),)" >> $AMAKEFILE
##########_ _ _ ####
#  ___ __| (_) |_  #
# / -_) _` | |  _| #
# \___\__,_|_|\__| #
####################
andhdl "com.qti.dpmframework" "jar"
andhdl "com.qti.location.sdk" "jar"
andhdl "dpmapi" "jar"
andhdl "qcnvitems" "jar"
andhdl "qcrilhook" "jar"
andhdl "tcmclient" "jar"
andhdl "qdcm_calib_data_mdss_dsi_ft8716_1080p_video" "xml"
andhdl "qdcm_calib_data_mdss_dsi_s6d6fa1_1080p_video" "xml"
andhdlib "libloc_api_v02"
andhdlib "libthermalclient"
andhdlib "libtime_genoff"
andhdlib "libTimeService"
andhdlib "libsdm-disp-apis"
andhdlib "libqct_resampler"
andhdlib "libavenhancements"
andhdlib "libmmparser"
andhdlib "libmmparser_lite"
####################
echo "endif" >> $AMAKEFILE

# Finish the Android.mk file by adjusting the last lines
# and adding the needed shell commands for EGL blobs.
# If the GPU blobs are handled externally, you can remove
# those commands.
# Since this is the end of the two files, you can apped here
# anything you'd need/want.
echo "" >> $AMAKEFILE
echo '$(shell mkdir -p $(PRODUCT_OUT)/system/vendor/lib/egl && pushd $(PRODUCT_OUT)/system/vendor/lib > /dev/null && ln -s egl/libEGL_adreno.so libEGL_adreno.so && popd > /dev/null)' >> $AMAKEFILE
echo '$(shell mkdir -p $(PRODUCT_OUT)/system/vendor/lib64/egl && pushd $(PRODUCT_OUT)/system/vendor/lib64 > /dev/null && ln -s egl/libEGL_adreno.so libEGL_adreno.so && popd > /dev/null)' >> $AMAKEFILE
echo "endif" >> $AMAKEFILE
echo "" >> $MAKEFILE
echo "endif" >> $MAKEFILE

# Bye.
echo ""
echo -e "${rose}We're${normal} ${cyan}${blink}DONE${normal} ${rose}here!${normal}"
