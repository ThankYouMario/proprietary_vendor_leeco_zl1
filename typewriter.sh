#!/bin/bash
#
# Copyright - √çcaro Hoff <icarohoff@gmail.com>
#
#  _                                  _ _
# | |_ _   _ _ __   _____      ___ __(_) |_ ___ _ __
# | __| | | | '_ \ / _ \ \ /\ / / '__| | __/ _ \ '__|
# | |_| |_| | |_) |  __/\ V  V /| |  | | ||  __/ |
#  \__|\__, | .__/ \___| \_/\_/ |_|  |_|\__\___|_|
#      |___/|_|
#
#

# "Sejhte"
set -e

# Colors
blink=$(tput blink)
red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
white=$(tput setaf 15)
rose=$(tput setaf 5)
cyan=$(tput setaf 14)
normal=$(tput sgr0)

# Verbose?
VERBOSE=$1

# Awesomeness
SCRIPT_VERSION="Alpha 1.0.1"
SCRIPT_DESCRIPTION="
A simple script that generates vendor makefiles
from a folder.
Creating copy and package rules as
they're put in the script itself."
WARNING_DESCRIPTION="
This is script is not one-for-them-all but rather an
edit-it-yourself sample script!"
echo -e "${rose}   _                                  _ _"
echo "  | |_ _   _ _ __   _____      ___ __(_) |_ ___ _ __"
echo -e "  | __| | | | '_ \ / _ \ \ /\ / / '__| | __/ _ \ '__|${normal}"
echo -e "${white}${blink}  | |_| |_| | |_) |  __/\ V  V /| |  | | ||  __/ |${normal}"
echo -e "${cyan}   \__|\__, | .__/ \___| \_/\_/ |_|  |_|\__\___|_|"
echo -e "       |___/|_|${normal}"
echo ""
echo -e "${rose}Version:${normal} ${cyan}$SCRIPT_VERSION${normal}"
printf "%s\n" "${white}$SCRIPT_DESCRIPTION${normal}"
printf "%s\n" "${red}$WARNING_DESCRIPTION${normal}"
echo ""
echo -e "${white}${blink}\/\/\/\/\/${normal} ${rose}Please${normal} ${cyan}${blink}WAIT${normal} ${rose}patiently!${normal} ${white}${blink}\/\/\/\/\/${normal}"
echo ""

# Device
VENDOR=leeco
DEVICE=zl1

# Variables
MAKEFILE=${DEVICE}-vendor.mk
AMAKEFILE=Android.mk
BMAKEFILE=BoardConfigVendor.mk
PROPRIETARY_FOLDER=proprietary
PROPRIETARY_INDEX=proprietary-index.txt

# Header
HEADER="# Copyright $(date +"%Y") Paranoid Android
#
# Licensed under the Apache License, Version 2.0 (the \"License\");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an \"AS IS\" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# This file was automatically generated by vendor/$VENDOR/$DEVICE/typewriter.sh."

# Write the header to the main makefile.
(cat << EOF) > $MAKEFILE
$HEADER
EOF

# Write the header to the board configuration makefile.
(cat << EOF) > $BMAKEFILE
$HEADER
EOF

# Typewriter essential function for querying the proprietary files
# based on the file extension/name argument.
function typwrt {
    if [ "$VERBOSE" = "-v" ]; then
        echo "Looking for [${2}] files under proprietary folder..."
    fi
    echo "" >> $MAKEFILE
    echo "# ${2}" >> $MAKEFILE
    echo -n "PRODUCT_COPY_FILES +=" >> $MAKEFILE
    if [ "$VERBOSE" = "-v" ]; then
        echo "Index:"
    fi
    FILES=$(git ls-files $PROPRIETARY_FOLDER --exclude="*${1}" --ignored)
    for FILE in $FILES; do
        TFILE=$(echo $FILE | sed 's/proprietary/system/')
        echo "/${TFILE}" >> $PROPRIETARY_INDEX
        if [ "$VERBOSE" = "-v" ]; then
            echo "   vendor/$VENDOR/$DEVICE/$FILE -> $TFILE"
        fi
        echo -n " \\
    vendor/$VENDOR/$DEVICE/$FILE:$TFILE" >> $MAKEFILE
    done
    if [ "$VERBOSE" = "-v" ]; then
        echo "Wrote [${1}] output to $MAKEFILE..."
    fi
    echo "" >> $MAKEFILE
}

# If a given blob is handled from Android.mk, we should remove it from
# the copy conditions to avoid trouble.
# Then we write the Android.mk source depending on the nature of that blob.
function andhdl {
    NAME=$1
    EXTENSION=$2
    TARGET=$(grep -E "$NAME.$EXTENSION" $PROPRIETARY_INDEX | sed 's/^[-\/]*//' | sed 's/system/proprietary/')
    if [ "$VERBOSE" = "-v" ]; then
        echo "Moving $NAME.$EXTENSION from $MAKEFILE to $AMAKEFILE..."
    fi
    NUM=$(grep -n "$TARGET" $MAKEFILE | sed 's/^\([0-9]\+\):.*$/\1/')
    PREV=$(expr $NUM - 1)
    NEXT=$(expr $NUM + 1)
    PLINE=$(head -n $PREV $MAKEFILE | tail -n 1)
    NLINE=$(head -n $NEXT $MAKEFILE | tail -n 1)
    # If the next line is blank, it's because the target is the last line and won't
    # have "\" at the end of the rule, we'd then remove the "\" from previous line
    # to avoid syntax issues before removing the target line itself.
    if [ $(echo $NLINE | grep -cvP '\S') == 1 ]; then
        echo -e "${yellow}Warning: Adjusting backslashes before removing $NAME.$EXTENSION...${normal}"
        REPLACE=$(echo $PLINE | sed 's/\\//g' | sed 's/ //g')
        sed -i "${PREV}s|.*|    ${REPLACE}|" $MAKEFILE
    fi
    # After we've checked the previous/next lines, we can safely remove
    # the target line itself.
    sed -i "${NUM}d" $MAKEFILE
    echo "
include \$(CLEAR_VARS)
LOCAL_MODULE := $NAME
LOCAL_MODULE_OWNER := $VENDOR" >> $AMAKEFILE
    if [ "$EXTENSION" = "jar" ]; then
        echo "LOCAL_MODULE_CLASS := JAVA_LIBRARIES" >> $AMAKEFILE
        echo -n "LOCAL_MODULE_SUFFIX := \$(COMMON_JAVA_PACKAGE_SUFFIX)" >> $AMAKEFILE
    elif [ "$EXTENSION" = "xml" ]; then
        echo "LOCAL_MODULE_CLASS := ETC" >> $AMAKEFILE
        echo -n "LOCAL_MODULE_SUFFIX := .xml" >> $AMAKEFILE
    fi
    echo "
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $TARGET
include \$(BUILD_PREBUILT)" >> $AMAKEFILE
    echo -n " \\
    $NAME" >> $MAKEFILE
}

# If a given lib is handled from Android.mk, we should remove it from
# the copy conditions to avoid trouble.
# Then we write the Android.mk source depending on the nature of that lib.
function andhdlib {
    NAME=$1
    if [ "$VERBOSE" = "-v" ]; then
        echo "Moving $NAME.so from $MAKEFILE to $AMAKEFILE..."
    fi
    TARGET64=$(grep -E "$NAME.so" $PROPRIETARY_INDEX | sed 's/^[-\/]*//' | sed 's/system/proprietary/' | if ! grep 'lib64/'; then echo "null"; fi)
    TARGET32=$(grep -E "$NAME.so" $PROPRIETARY_INDEX | sed 's/^[-\/]*//' | sed 's/system/proprietary/' | if ! grep 'lib/'; then echo "null"; fi)
    if [ "$TARGET32" = "null" ]; then
        echo "Library only available for 64-bit."
        ARCH=64
    elif [ "$TARGET64" = "null" ]; then
        echo "Library only available for 32-bit."
        ARCH=32
    else if [[ ! "$TARGET32" = "null" || "$TARGET64" = "null" ]]; then
        echo "Library available for both (64-bit/32-bit)."
        ARCH=both
    fi
    fi
    #TARGET32=$(echo $TARGET | if ! grep 'lib/'; then echo "ZSSHSHSH"; fi)
    echo "64-bit: $TARGET64"
    echo "32-bit: $TARGET32"
    if [ "$ARCH" = "32" ]; then
        NUM=$(grep -n "$TARGET32" $MAKEFILE | sed 's/^\([0-9]\+\):.*$/\1/')
        PREV=$(expr $NUM - 1)
        NEXT=$(expr $NUM + 1)
    elif [ "$ARCH" = "64" ]; then
        NUM=$(grep -n "$TARGET64" $MAKEFILE | sed 's/^\([0-9]\+\):.*$/\1/')
        PREV=$(expr $NUM - 1)
        NEXT=$(expr $NUM + 1)
    else if [ "$ARCH" = "both" ]; then
        NUM32=$(grep -n "$TARGET32" $MAKEFILE | sed 's/^\([0-9]\+\):.*$/\1/')
        NUM64=$(grep -n "$TARGET64" $MAKEFILE | sed 's/^\([0-9]\+\):.*$/\1/')
        PREV32=$(expr $NUM32 - 1)
        PREV64=$(expr $NUM64 - 1)
        NEXT32=$(expr $NUM32 + 1)
        NEXT64=$(expr $NUM64 + 1)
    fi
    fi
    if [ "$ARCH" = "both" ]; then
        PLINE32=$(head -n $PREV32 $MAKEFILE | tail -n 1)
        PLINE64=$(head -n $PREV64 $MAKEFILE | tail -n 1)
        NLINE32=$(head -n $NEXT32 $MAKEFILE | tail -n 1)
        NLINE64=$(head -n $NEXT64 $MAKEFILE | tail -n 1)
    else
        PLINE=$(head -n $PREV $MAKEFILE | tail -n 1)
        NLINE=$(head -n $NEXT $MAKEFILE | tail -n 1)
    fi
    # If the next line is blank, it's because the target is the last line and won't
    # have "\" at the end of the rule, we'd then remove the "\" from previous line
    # to avoid syntax issues before removing the target line itself.
    if [ "$ARCH" = "both" ]; then
        # 32-bit library in last line position.
        if [ $(echo $NLINE32 | grep -cvP '\S') == 1 ]; then
            echo -e "${yellow}Warning: Adjusting backslashes before removing 32-bit $NAME.so...${normal}"
            REPLACE32=$(echo $PLINE32 | sed 's/\\//g' | sed 's/ //g')
            sed -i "${PREV32}s|.*|    ${REPLACE32}|" $MAKEFILE
        fi
        # 64-bit library in last line position.
        if [ $(echo $NLINE64 | grep -cvP '\S') == 1 ]; then
            echo -e "${yellow}Warning: Adjusting backslashes before removing 64-bit $NAME.so...${normal}"
            REPLACE64=$(echo $PLINE64 | sed 's/\\//g' | sed 's/ //g')
            sed -i "${PREV64}s|.*|    ${REPLACE64}|" $MAKEFILE
        fi
    else
        if [ $(echo $NLINE | grep -cvP '\S') == 1 ]; then
            echo -e "${yellow}Warning: Adjusting backslashes before removing $NAME.so...${normal}"
            REPLACE=$(echo $PLINE | sed 's/\\//g' | sed 's/ //g')
            sed -i "${PREV}s|.*|    ${REPLACE}|" $MAKEFILE
        fi
    fi
    # After we've checked the previous/next lines, we can safely remove
    # the target line itself.
    if [ "$ARCH" = "both" ]; then
        sed -i "${NUM32}d" $MAKEFILE
        sed -i "${NUM64}d" $MAKEFILE
    else
        sed -i "${NUM}d" $MAKEFILE
    fi
    echo "
include \$(CLEAR_VARS)
LOCAL_MODULE := $NAME
LOCAL_MODULE_OWNER := $VENDOR" >> $AMAKEFILE
    if [ "$ARCH" = "32" ]; then
        echo -n "LOCAL_MULTILIB := 32" >> $AMAKEFILE
    elif [ "$ARCH" = "64" ]; then
        echo -n "LOCAL_MULTILIB := 64" >> $AMAKEFILE
    else if [ "$ARCH" = "both" ]; then
        echo -n "LOCAL_MULTILIB := both" >> $AMAKEFILE
    fi
    fi
    echo "
LOCAL_MODULE_CLASS := SHARED_LIBRARIES
LOCAL_MODULE_SUFFIX := .so
LOCAL_MODULE_TAGS := optional" >> $AMAKEFILE
    if [ "$ARCH" = "32" ]; then
        echo "LOCAL_SRC_FILES := $TARGET32" >> $AMAKEFILE
    elif [ "$ARCH" = "64" ]; then
        echo "LOCAL_SRC_FILES := $TARGET64" >> $AMAKEFILE
    else if [ "$ARCH" = "both" ]; then
        echo "LOCAL_SRC_FILES_64 := $TARGET64" >> $AMAKEFILE
        echo "LOCAL_SRC_FILES_32 := $TARGET32" >> $AMAKEFILE
    fi
    fi
echo "include \$(BUILD_PREBUILT)" >> $AMAKEFILE
    echo -n " \\
    $NAME" >> $MAKEFILE
}

# Executables
# Because "git ls-files" doesn't handle files without
# extensions properly we ought to use "find" instead.
# Note that for "find" command not to use absolute paths
# we'll hardcode the proprietary path.
if [ "$VERBOSE" = "-v" ]; then
    echo "Looking for executable files under proprietary folder..."
fi
echo "" >> $MAKEFILE
echo "# Executable Files" >> $MAKEFILE
echo -n "PRODUCT_COPY_FILES +=" >> $MAKEFILE
if [ "$VERBOSE" = "-v" ]; then
    echo "Index:"
fi
EXECUTABLES=$(find proprietary -executable -type f | sort -u)
for EXECUTABLE in $EXECUTABLES; do
    TEXECUTABLE=$(echo $EXECUTABLE | sed 's/proprietary/system/')
    echo "/${TEXECUTABLE}" > $PROPRIETARY_INDEX
    if [ "$VERBOSE" = "-v" ]; then
        echo "   vendor/$VENDOR/$DEVICE/$EXECUTABLE -> $TEXECUTABLE"
    fi
    echo -n " \\
    vendor/$VENDOR/$DEVICE/$EXECUTABLE:$TEXECUTABLE" >> $MAKEFILE
done
if [ "$VERBOSE" = "-v" ]; then
    echo "Wrote executables output to $MAKEFILE..."
fi
echo "" >> $MAKEFILE

# Pass the different file types to the common function
# to be parsed and wrote.
# Please, use alphabetical order to make the output file
# easier to understand and navigate.
typwrt ".acdb"  "ACDB"
typwrt ".conf"  "Configuration (A)"
typwrt ".cfg"   "Configuration (B)"
typwrt ".db"    "Database"
typwrt ".jar"   "Java Files"
typwrt ".xml"   "Parsable Files"
typwrt ".so"    "Libraries"
typwrt ".qcom"  "QCOM Files"
typwrt "b0*"    "Firmware Files (A)" # b00, b01, b02, b03...
typwrt ".mbn"   "Firmware Files (B)"
typwrt ".mdt"   "Firmware Files (C)"
typwrt ".elf"   "Firmware Files (D)"
typwrt ".img"   "Firmware Files (E)"
typwrt ".tlv"   "Firmware Files (F)"
typwrt ".bin"   "Firmware Files (G)"
typwrt ".fw"    "Firmware Files (H)"
typwrt ".fw2"   "Firmware Files (I)"
typwrt ".cybin" "Type-C Firmware"
typwrt ".gmm"   "QVOP Firmware"

# Exception cases for files that don't have an extension,
# use the complete name of the file in this case.
typwrt "mbn_upgrade_info"  "Modem Upgrade Info"

# Applications
# This will write the apps to the proprietary index.
if [ "$VERBOSE" = "-v" ]; then
    echo "Looking for apps under proprietary folder..."
    echo "Index:"
fi
APPS=$(git ls-files $PROPRIETARY_FOLDER --exclude="*.apk" --ignored)
for APP in $APPS; do
    TAPP=$(echo $APP | sed 's/proprietary/system/')
    echo "/${TAPP}" >> $PROPRIETARY_INDEX
    if [ "$VERBOSE" = "-v" ]; then
        echo "   vendor/$VENDOR/$DEVICE/$APP -> $TAPP"
    fi
done

# Write out the Android.mk using the proprietary apps
# found on the index.
HAS_APK=false
for APP in $(cat $PROPRIETARY_INDEX | grep -v -E '^ *(#|$)' | grep -E '\.apk *$' | sed 's/^[-\/]*//' | sed 's/system/proprietary/' | sort -s); do
    APK_NAME=$(basename -s .apk $APP)
    if [ "$HAS_APK" != "true" ]; then
        echo -n "
# Applications
PRODUCT_PACKAGES +=" >> $MAKEFILE
        (cat << EOF) > $AMAKEFILE
$HEADER

LOCAL_PATH := \$(call my-dir)

ifeq (\$(TARGET_DEVICE),$DEVICE)

-include vendor/head/zl1/head.mk
EOF
        HAS_APK=true
    fi
    echo -n " \\
    $APK_NAME" >> $MAKEFILE
    echo "
include \$(CLEAR_VARS)
LOCAL_MODULE := $APK_NAME
LOCAL_MODULE_OWNER := $VENDOR
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := \$(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_MODULE_TAGS := optional
LOCAL_DEX_PREOPT := false
LOCAL_CERTIFICATE := platform" >> $AMAKEFILE
    if [[ "$APP" =~ "system/priv-app/".* ]]; then
        echo "LOCAL_PRIVILEGED_MODULE := true" >> $AMAKEFILE
    fi
    echo "LOCAL_SRC_FILES := $APP
include \$(BUILD_PREBUILT)" >> $AMAKEFILE
done
echo "" >> $MAKEFILE

# Android.mk handled blobs need to use packages as well.
# This is fairly common on QCOM devices.
echo -n "
# QCOM Packages
ifeq (\$(QCPATH),)
PRODUCT_PACKAGES +=" >> $MAKEFILE
echo "" >> $AMAKEFILE
echo -n "ifeq (\$(QCPATH),)" >> $AMAKEFILE
andhdl "com.qti.dpmframework" "jar"
andhdl "com.qti.location.sdk" "jar"
andhdl "dpmapi"               "jar"
andhdl "qcnvitems"            "jar"
andhdl "qcrilhook"            "jar"
andhdl "tcmclient"            "jar"
andhdl "qdcm_calib_data_mdss_dsi_ft8716_1080p_video"  "xml"
andhdl "qdcm_calib_data_mdss_dsi_s6d6fa1_1080p_video" "xml"
andhdlib "libloc_api_v02"
andhdlib "libthermalclient"
echo "endif" >> $AMAKEFILE

# Finish the Android.mk file by adjusting the last lines
# and adding the needed shell commands for EGL blobs.
echo "" >> $AMAKEFILE
echo '$(shell mkdir -p $(PRODUCT_OUT)/system/vendor/lib/egl && pushd $(PRODUCT_OUT)/system/vendor/lib > /dev/null && ln -s egl/libEGL_adreno.so libEGL_adreno.so && popd > /dev/null)' >> $AMAKEFILE
echo '$(shell mkdir -p $(PRODUCT_OUT)/system/vendor/lib64/egl && pushd $(PRODUCT_OUT)/system/vendor/lib64 > /dev/null && ln -s egl/libEGL_adreno.so libEGL_adreno.so && popd > /dev/null)' >> $AMAKEFILE
echo "endif" >> $AMAKEFILE

# Finish the makefile file by adding the last blank line.
echo "" >> $MAKEFILE
echo "endif" >> $MAKEFILE

# Bye.
echo ""
echo -e "${white}${blink}\/\/\/\/\/${normal} ${rose}We're${normal} ${cyan}${blink}DONE${normal} ${rose}here!${normal} ${white}${blink}\/\/\/\/\/${normal}"
